{
  "data": {
    "lesson": {
      "id": 848090,
      "key": "1b070391-5afa-4633-9fd3-de9df0286472",
      "title": "Operationalizing Microservices",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "Learn about continuous integration and development (CI/CD pipeline) and implement fault-tolerance and load tests to create more robust applications.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/1b070391-5afa-4633-9fd3-de9df0286472/848090/1582839996035/Operationalizing+Microservices+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/1b070391-5afa-4633-9fd3-de9df0286472/848090/1582839992321/Operationalizing+Microservices+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 859155,
          "key": "0c3d2482-a4aa-468c-935b-1ad616f47229",
          "title": "Alerts and Incidents Response",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "0c3d2482-a4aa-468c-935b-1ad616f47229",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 900428,
              "key": "3f729fcf-ec27-4cdd-a56e-cad9912edbf8",
              "title": "Untitled",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Alerts and Incidents Response",
              "instructor_notes": ""
            },
            {
              "id": 859590,
              "key": "d78619ad-2a66-4143-b18b-10a7063637d4",
              "title": "ND#9991 C04 L05 A01 Alerts And Incedent Response",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "7fz86xAInPo",
                "china_cdn_id": "7fz86xAInPo.mp4"
              }
            },
            {
              "id": 980853,
              "key": "1c9ab2d0-30af-44f7-aaa0-e6950f62e1e8",
              "title": "Operationalizing a Microservice Overview",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Operationalizing a Microservice Overview\n\nOne important factor in developing a microservice is to think about the feedback loop.  In this diagram, a [GitOps](https://queue.acm.org/detail.cfm?id=3237207) style workflow is described.  \n\n1. Application is stored in Git.\n2. Changes in Git trigger the continuous delivery server which then tests and deploys the code to a new environment.  This environment is configured as Infrastructure as Code (IaC).\n3. The microservice, which could be a containerized service running in Kubernetes or a FaaS (Function as a Service) running on AWS Lambda, has logging, metrics, and instrumentation.\n4. A load test using a tool like [locust](https://locust.io/).\n\n![operationalize-microservice](https://user-images.githubusercontent.com/58792/73959929-11621d80-48d8-11ea-9d9a-8a29b802cb96.png)\n\n5. When the performance and auto-scaling is verified the code is merged to production and deployed\n\nWhat are some of the items that could be alerted on with Kubernetes?\n\n* Alerting on application layer metrics\n* Alerting on services running on Kubernetes\n* Alerting on the Kubernetes infrastructure\n* Alerting on the host/node layer\n\nHow could you collect metrics with Kubernetes and Prometheus?  Here is a diagram that walks through a potential workflow. Note that there are two pods.  One pod is dedicated to the Prometheus collector and the second pod has a \"sidecar\" Prometheus container that sits alongside the Flask application. This all propagates up to a centralized monitoring system that visualizes the health of the clusters and trigger alerts.\n\n![prometheus-kubernetes](https://user-images.githubusercontent.com/58792/73962194-f691a800-48db-11ea-8969-0d6c74827599.png)\n\nAnother helpful resource is an official sample project from Google Cloud [Monitoring apps running on multiple GKE clusters using Prometheus and Stackdriver](https://cloud.google.com/solutions/monitoring-apps-running-on-multiple-gke-clusters-using-prometheus-and-stackdriver).\n",
              "instructor_notes": ""
            },
            {
              "id": 859613,
              "key": "bcd6af9d-9d64-4059-b78e-87a2a662a76c",
              "title": "Untitled",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### Reference\n- [Monitor Node Health](https://kubernetes.io/docs/tasks/debug-application-cluster/monitor-node-health/)",
              "instructor_notes": ""
            },
            {
              "id": 980850,
              "key": "41510b64-bb21-4379-993f-1a91ddf13bdc",
              "title": "Creating effective alerts",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Creating Effective Alerts\n\nAt one company I worked at there was a homegrown monitoring system (again, initially created by the founders) that alerted on average every 3-4 hours, 24 hours a day.\n\nBecause everyone in engineering, except the CTO, was on call, most of the engineering staff was always sleep deprived. This system guaranteed that every night there were alerts about the system not working. The \"fix\" to the alerts was to restart services.  I volunteered to be on call for one month straight to allow engineering the time to fix the problem.  This sustained period of suffering and lack of sleep led me to realize several things:  **one**, the monitoring system was no better than random;  **two**, I could potentially replace the entire system with a *random coin flip*.\n\n",
              "instructor_notes": ""
            },
            {
              "id": 980856,
              "key": "10f661bf-df3e-41e8-9bdb-25726523a7ea",
              "title": "Scenario Image",
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2020/February/5e575f47_monitoring/monitoring.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/10f661bf-df3e-41e8-9bdb-25726523a7ea",
              "caption": "**Alerts by Day**",
              "alt": "Graph of Alert by Day",
              "width": 2864,
              "height": 2076,
              "instructor_notes": null
            },
            {
              "id": 980851,
              "key": "b5b85e48-d878-44c1-a080-06a6a56db780",
              "title": "Story Continued",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Even more distressing, when looking at the data, it was clear that engineers had spent YEARS of their lives responding to pages and getting woken up at night. All that, and it was utterly useless.  The suffering and sacrifice accomplished nothing and reinforced the sad truth that life is not fair.  The unfairness of the situation was quite depressing, and it took quite a bit of convincing to get people to agree to turn off the alerts.  There is a built-in bias in human behavior to continue to do what you have always done.  Additionally, because the suffering was so severe and sustained, there was a tendency to attribute a deeper meaning to it.  Ultimately, it was a false God. \n\n*Reference: Gift, Noah (2020) Python for DevOps: pg. 226*\n",
              "instructor_notes": ""
            },
            {
              "id": 900427,
              "key": "7b768f39-bac8-4e5f-9523-0281e9a80d37",
              "title": "Worse than No Alerts",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "7b768f39-bac8-4e5f-9523-0281e9a80d37",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What can be worse than not having alerts for critical failures?",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "Too many alerts",
                    "is_correct": true
                  },
                  {
                    "id": "rbk2",
                    "text": "Alerts that are not actionable",
                    "is_correct": true
                  },
                  {
                    "id": "rbk3",
                    "text": "Alerts that can be automated but are not",
                    "is_correct": true
                  },
                  {
                    "id": "rbk4",
                    "text": "Alerts that compromise the health of employees",
                    "is_correct": true
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 859591,
          "key": "6bdf3a00-4aa8-4d29-9f83-0092c692d9f6",
          "title": "Disaster Recovery",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "6bdf3a00-4aa8-4d29-9f83-0092c692d9f6",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 980852,
              "key": "de2aa283-1367-46ee-9fe8-10f6e3a5be7c",
              "title": "Serverless Best Practices, Disaster Recovery and Backups for Microservices",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Disaster Recovery\n\nAn important but often overlooked part of building production software is designing for failure.  There is an expression that the only two certainties in life are death and taxes.  We can add another certainty to the list, software system failure.  In the AWS whitepaper [Serverless Application Lens](https://d1.awsstatic.com/whitepapers/architecture/AWS-Serverless-Applications-Lens.pdf) they discuss five pillars of a well architected serverless system:  operational excellence, reliability, performance efficiency and cost optimization.  *It is highly recommended to read this guide thoroughly.*\n\n### Five Pillars of a Well Architected Serverless System\n\n#### Operational Excellence  \n\nHow do you understand the health of a serverless application? One method is to use metrics and alerts.  These metrics could include business metrics, customer experience metrics and other metrics.  Another method is to have centralized logging.  This allows for unique transactions ideas that can narrow down critical failures.\n\n#### Security\n\nHave proper controls and using the POLP (Principle of Least Privilege).  Only give out the privileges needed to complete a task to a user, service or developer.  Protect data at rest and in transit.\n\n#### Reliability\n\nPlan on the fact that failure will occur.  Have retry logic for key service and build a system that can queue work when a service is unavailable.  Use highly available services that store multiple copies of the data like Amazon S3 and then archive key data to services that can store immutable backups.  Ensure that you have tested these backups and validated them on a recurring basis (say quarterly)\n\n#### Performance\n\nOne key way to validate performance is to load test an application that has proper instrumentation and logging.  Several load test tools include:  [Apache Bench](https://httpd.apache.org/docs/2.4/programs/ab.html), [Locust](https://locust.io/) and load test services like [loader.io](https://loader.io/)\n\n#### Cost\n\nServerless technologies like AWS Lambda fit well with cost optimization because they are driven by usage.  Events trigger the execution of services and this saves a tremendous amount on cost if the architecture is designed to take advantage of this.  \n\n### Summary of Serverless Best Practices\n\nOne of the advantages of serverless application development is that it encourages the use of IaC and GitOps on top of highly durable infrastructure.  This means that entire environments can be spun up to mitigate severe unplanned outages in geographic regions.  Additionally, the use of automated load testing alongside comprehensive instrumentation and logging leads to environments that are robust in the face of disasters.\n",
              "instructor_notes": ""
            },
            {
              "id": 859592,
              "key": "ee058a5e-d370-4b0b-866a-7cc06fb2518d",
              "title": "ND#9991 C04 L05 A02 Disaster Recovery",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "m2XVJHfwSTw",
                "china_cdn_id": "m2XVJHfwSTw.mp4"
              }
            },
            {
              "id": 859614,
              "key": "e70a69f3-11c1-466d-a1d1-4a8ac7947edb",
              "title": "Untitled",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Reference\n- Backup and Migrate Kubernetes: [LINK](https://github.com/heptio/velero)",
              "instructor_notes": ""
            },
            {
              "id": 900431,
              "key": "3900a963-edf0-49fc-8772-b351e5f1209a",
              "title": "Disaster Recovery",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "3900a963-edf0-49fc-8772-b351e5f1209a",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What are some core principles of Disaster Recovery?",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "More than one copy of critical data",
                    "is_correct": false
                  },
                  {
                    "id": "rbk2",
                    "text": "Test restoring backups regularly",
                    "is_correct": false
                  },
                  {
                    "id": "rbk3",
                    "text": "Both of the above",
                    "is_correct": true
                  },
                  {
                    "id": "rbk4",
                    "text": "Back it up and forget about it",
                    "is_correct": false
                  },
                  {
                    "id": "rbk5",
                    "text": "Snapshots trump everything",
                    "is_correct": false
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 859593,
          "key": "245689f3-a216-45ad-bc68-7b334786c606",
          "title": "CI/CD Pipeline Integration",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "245689f3-a216-45ad-bc68-7b334786c606",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 900430,
              "key": "20de94e3-8469-4027-8385-84b98fcc54e4",
              "title": "Untitled",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## CI/CD Pipeline Integration",
              "instructor_notes": ""
            },
            {
              "id": 859594,
              "key": "427cf343-fb08-4cf6-9648-ee52609dd5e9",
              "title": "ND#9991 C04 L05 A02 CI-CD Pipeline Integration",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "zTIbWr_1X2I",
                "china_cdn_id": "zTIbWr_1X2I.mp4"
              }
            },
            {
              "id": 859616,
              "key": "a12f94f8-feed-4916-9638-7415f2028b09",
              "title": "Untitled",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Earlier in the course, we briefly touched on CircleCI through its inclusion within a `Makefile` Noah used.\n\nCircleCI is a great tool to help with continuous integration, and it works well with Kubernetes. You can read some information in this [CircleCI blog post](https://circleci.com/blog/k8s-deployments-with-cloudflare/) on one application combining Kubernetes with CircleCI, and on the next page, it will be your turn to add CircleCI to your build.",
              "instructor_notes": ""
            },
            {
              "id": 900432,
              "key": "c74f9e8a-ce0b-444e-aff8-a61d15fbac0b",
              "title": "CI/CD",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "c74f9e8a-ce0b-444e-aff8-a61d15fbac0b",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What problem does CI/CD solve?",
                "answers": [
                  {
                    "id": "rbk1",
                    "text": "Helps ensure software is always ready for delivery",
                    "is_correct": true
                  },
                  {
                    "id": "rbk2",
                    "text": "Eliminates the need for any testing",
                    "is_correct": false
                  },
                  {
                    "id": "rbk3",
                    "text": "It eliminates the need for ports to be exposed internal, externally and in a cluster",
                    "is_correct": false
                  },
                  {
                    "id": "rbk4",
                    "text": "All of the above",
                    "is_correct": false
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 906283,
          "key": "f2fa834d-1be2-4410-9eb9-94d0afab3a2b",
          "title": "Exercise: CircleCI",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "f2fa834d-1be2-4410-9eb9-94d0afab3a2b",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 906284,
              "key": "60e05882-913f-42e0-916c-c4784ad368a6",
              "title": "Untitled",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Exercise: CircleCI\n\nIt is easy to look at build servers as a nice to have when they are a must-have for DevOps best practices.  One ubiquitous cloud-based build server is CircleCI.  In this exercise, you will incorporate many of the concepts from this course:  Docker, Makefiles, and build systems.\n\n### Instructions\n\n- Create and use an [AWS Cloud9 environment](https://aws.amazon.com/cloud9/). (We also have a video tutorial in a previous lesson.)\n- Change the template below and add to your `Makefile` (this template is similar to what we used in earlier lessons).\n- Install `hadolint` by [downloading it here](https://github.com/hadolint/hadolint/releases/tag/v1.17.5).\n- Run `make lint` and make sure you are able to lint both Python code and a `Dockerfile`\n- _Optional_ Setup CircleCI integration.  Remember you can also refer back to the Docker setup screencast in Lesson 4 to see more ideas on `hadolint`.",
              "instructor_notes": ""
            },
            {
              "id": 906285,
              "key": "982ea958-a943-414f-a76e-dd91b67c12a3",
              "title": "Untitled",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### Makefile template \n\n```Makefile\nsetup:\n\tpython3 -m venv ~/.udacity-devops\n\ninstall:\n\tpip install --upgrade pip &&\\\n\t\tpip install -r requirements.txt\n\ntest:\n\t#python -m pytest -vv --cov=myrepolib tests/*.py\n\t#python -m pytest --nbval notebook.ipynb\n\n\nlint:\n\thadolint demos/flask-sklearn/Dockerfile\n\tpylint --disable=R,C,W1203 demos/**/**.py\n\nall: install lint test\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 859595,
          "key": "70e9da2f-fed4-4014-8a11-f51c244be498",
          "title": "Load Testing",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "70e9da2f-fed4-4014-8a11-f51c244be498",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 906286,
              "key": "13a29b68-0aee-4b4f-8062-bd41a45f0c9f",
              "title": "Untitled",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Load Testing",
              "instructor_notes": ""
            },
            {
              "id": 859596,
              "key": "004c135c-1aea-463b-94b5-ad2b7ef15fd8",
              "title": "ND#9991 C04 L05 A04 CI-CD Load Testing",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "8Lg_mIoMQ74",
                "china_cdn_id": "8Lg_mIoMQ74.mp4"
              }
            },
            {
              "id": 859617,
              "key": "b2acae9a-b5f8-41cc-afca-f7157848c550",
              "title": "Untitled",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "On the next page, you'll get a chance to first load test a sample app with Locust, and then work to scale up this sample app to better handle higher loads.\n\n### Reference\n- Locust Helm Chart: [LINK](https://github.com/helm/charts/tree/master/stable/locust)",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 900653,
          "key": "a0590d6d-d81a-4920-b52e-eabee05a578f",
          "title": "Exercise: Locust Load Testing",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "a0590d6d-d81a-4920-b52e-eabee05a578f",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 980854,
              "key": "a0545e0b-a9ba-49e6-84cd-694e407ba070",
              "title": "Header",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Exercise: Locust Load Testing\n\nLoad testing is a critical part of developing a reliable Microservice.  This allows you to verify that the application can perform at scale.  In this exercise, you will set up a basic load test with locust.",
              "instructor_notes": ""
            },
            {
              "id": 980857,
              "key": "2f1ddead-c2d6-447e-994d-0366373fb880",
              "title": "Docker-Flask-Locust",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "RDmLNEFrq8E",
                "china_cdn_id": "RDmLNEFrq8E.mp4"
              }
            },
            {
              "id": 980860,
              "key": "6b42aeeb-5060-4cfa-a4cc-507f2c547eab",
              "title": "Exercise: Locust Load Testing",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "6b42aeeb-5060-4cfa-a4cc-507f2c547eab",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "Install locust using instructions [here](https://docs.locust.io/en/latest/installation.html).",
                "Configure a basic load test of the predict service endpoint in the sample app as shown [here](https://docs.locust.io/en/latest/quickstart.html).",
                "Find out how many requests your application accepts before latency significantly rises or crashes. What is that number?",
                "Come up with a solution that will scale this on your own laptop or desktop (consider whether you can use some of the scaling techniques in the last lesson here!).",
                "Verify that you have solved your first bottleneck and increased the requests per second at least 10% higher."
              ],
              "positive_feedback": "Great job!",
              "video_feedback": null,
              "description": "Below this task list is a walkthrough of some of what was shown in the video. Use that as a helpful resource while you work through this exercise."
            },
            {
              "id": 900654,
              "key": "b24b5762-6cad-43f4-9865-095b1588a8d8",
              "title": "Untitled",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Creating a Locust Loadtest with Flask \n\nOne powerful way to create a simple loadtest is with Locust and Flask.  Here is an example of a simple flask hello world app.  The [entire source code is found here](https://github.com/noahgift/docker-flask-locust).\n\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello, World!'\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=8080, debug=True)\n```\n\nThe loadtest file is very simple to configure.  Notice the `index` function calls into the main, and only flask route.\n\n```python\nfrom locust import HttpLocust, TaskSet, between\n\ndef index(l):\n    l.client.get(\"/\")\n\nclass UserBehavior(TaskSet):\n    tasks = {index: 1}\n\nclass WebsiteUser(HttpLocust):\n    task_set = UserBehavior\n    wait_time = between(5.0, 9.0)\n```\n\nThe login screen requires the number of users and also hostname and port.  In our case this will be the port 8080.\n\n![Screen Shot 2020-02-07 at 7 12 18 PM](https://user-images.githubusercontent.com/58792/74074801-c7635f80-49dd-11ea-9273-a04b587bbc05.png)\n\nYou can see how locust works when it runs.\n\n![Screen Shot 2020-02-07 at 7 08 49 PM](https://user-images.githubusercontent.com/58792/74074716-65a2f580-49dd-11ea-943d-f91229a690ef.png)",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 859597,
          "key": "b85dc677-a10b-49b4-b003-80e1048c74b0",
          "title": "Summary",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "b85dc677-a10b-49b4-b003-80e1048c74b0",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 980855,
              "key": "ff4774ec-98c2-4f9f-b3ed-0962098ba820",
              "title": "Summary Header",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Lesson Summary",
              "instructor_notes": ""
            },
            {
              "id": 859598,
              "key": "5f416c23-470f-4706-b981-9791a954c8de",
              "title": "ND#9991 C04 L05 A05 Summary",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "bN1o0VvvGbQ",
                "china_cdn_id": "bN1o0VvvGbQ.mp4"
              }
            },
            {
              "id": 980858,
              "key": "14646557-cb39-4b2b-86e5-e45f7f7c1c62",
              "title": "Key Terms",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Key Terms:\n\n#### Alerts\n\nAlerts are health metrics that have actions associated with them. An example would be an alert that sends a text message to a software engineer when a web service returns multiple error status codes.\n\n#### Operationalization\n\nThe process of making an application ready for production deployment. These actions could include monitoring, load-testing, setting up alerts, and load-testing.\n\n#### Metrics\n\nMetrics are the creation of KPIs (Key Performance Indicators) for a software application. An example of a parameter is the percentage of CPU used by a server.\n\n#### Disaster recovery\n\nDisaster recovery is the process of designing a software system to recover despite a disaster. This process could include archiving data to another location.\n\n#### Migrate\n\nMigrate is the ability to move an application from one environment to another.  \n\n#### Continuous Integration\n\nContinuous Integration is the process of automatically testing software upon check in to the source control system.\n\n#### Continuous Delivery\n\nContinuous Delivery is the process of delivering tested software automatically to any environment.\n\n#### Load Testing\n\nLoad testing is the process of verifying the scale characteristics of a software system.\n\n#### Locust\n\nLocust is a load-testing framework that accepts Python formatted load test scenarios.\n\n*Source: https://noahgift.github.io/cloud-data-analysis-at-scale/topics/key-terms*\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 859599,
          "key": "e84cd6ca-ef7c-44d9-8a31-11d0173e31ff",
          "title": "Course Wrap Up",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "e84cd6ca-ef7c-44d9-8a31-11d0173e31ff",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 980859,
              "key": "4e7cdff6-aefd-443e-b4b3-7e4f4f134e67",
              "title": "Course Summary Header",
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Course Summary",
              "instructor_notes": ""
            },
            {
              "id": 859600,
              "key": "0e579a25-0004-414d-9158-ce4669504f28",
              "title": "ND#9991 C04 L05 A06 Course Wrap Up",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "gsb7XtmJ04U",
                "china_cdn_id": "gsb7XtmJ04U.mp4"
              }
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}